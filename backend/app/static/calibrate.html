<!DOCTYPE html>
<html lang="ko">
<head>
  <meta charset="utf-8" />
  <title>개인바프 캘리브레이션 v2 (BlazePose)</title>
  <meta name="viewport" content="width=device-width, initial-scale=1" />
  <link rel="icon" href="data:," />
  <style>
    :root{--bg:#0b0b0c;--fg:#e9eef6;--muted:#9aa4ad;--card:#121418;--line:#1d2026;--accent:#6fd3ff;--ok:#3fd37c;--warn:#ffd66e;--bad:#ff6b6b}
    *{box-sizing:border-box}
    body{margin:0;background:var(--bg);color:var(--fg);font-family:system-ui,-apple-system,Segoe UI,Roboto,Apple SD Gothic Neo,Pretendard}
    .wrap{max-width:1200px;margin:24px auto;padding:0 16px}
    h1{margin:0 0 12px;font-size:22px}
    .grid{display:grid;grid-template-columns:1.2fr .8fr;gap:16px}
    .card{background:var(--card);border:1px solid var(--line);border-radius:14px;padding:14px}
    .toolbar{display:flex;gap:8px;align-items:center;flex-wrap:wrap}
    button,select,input{background:#12161c;color:var(--fg);border:1px solid #252a33;border-radius:10px;padding:8px 12px}
    button{cursor:pointer} button:disabled{opacity:.6;cursor:not-allowed}
    label{color:var(--muted);font-size:13px;display:inline-flex;align-items:center;gap:6px}
    #stage{position:relative;width:100%;aspect-ratio:16/9;background:#0e1014;border-radius:14px;overflow:hidden;margin-top:10px}
    video,canvas{position:absolute;inset:0;width:100%;height:100%;object-fit:cover}
    video{transform:scaleX(-1)} /* 거울 모드 */
    .hud{position:absolute;top:10px;left:10px;background:rgba(0,0,0,.45);padding:8px 12px;border-radius:10px;font-size:13px;max-width:84%}
    .pill{display:inline-block;padding:2px 10px;border-radius:999px;background:#17212b;color:#b9c3ce;font-size:12px}
    .row{display:flex;gap:10px;flex-wrap:wrap;align-items:center}
    .kv{display:flex;justify-content:space-between;gap:8px;padding:6px 0;border-bottom:1px dashed #222}
    .kv:last-child{border:none}
    .sec{font-size:14px;color:#b9c3ce;margin:10px 0 6px}
    .hint{color:var(--muted);font-size:13px}
    .ok{color:var(--ok)} .warn{color:var(--warn)} .bad{color:var(--bad)}
    textarea{width:100%;min-height:180px;background:#0e1218;color:#d9e6ff;border:1px solid #253045;border-radius:10px;padding:10px;font-family:ui-monospace,Menlo,Consolas,'D2Coding',monospace;font-size:12px}
    .progress{height:8px;background:#1a1e25;border-radius:20px;overflow:hidden}
    .bar{height:100%;width:0%;background:linear-gradient(90deg,#39b3ff,#9af7ff)}
    .chips{display:flex;gap:6px;flex-wrap:wrap}
    .chip{font-size:12px;background:#141b22;border:1px solid #223042;color:#cfe8ff;padding:4px 8px;border-radius:999px}
  </style>

  <!-- ✅ 로컬에 둔 UMD 번들 로드 -->
  <script src="/static/lib/tf.min.js"></script>
  <script src="/static/lib/pose-detection.min.js"></script>
</head>
<body>
<div class="wrap">
  <h1>개인바프 캘리브레이션</h1>

  <div class="grid">
    <!-- LEFT -->
    <div class="card">
      <div class="toolbar">
        <button id="btnStart">카메라 시작</button>
        <button id="btnStop" disabled>중지</button>
        <label>카메라 <select id="camera"></select></label>
        <label>해상도
          <select id="reso">
            <option value="1280x720" selected>1280×720</option>
            <option value="640x480">640×480</option>
          </select>
        </label>
        <label><input id="chkMask" type="checkbox"> 인물 마스크</label>
        <span class="pill" id="stepPill">STEP 0/4: 준비</span>
        <div class="progress" style="flex:1 1 160px"><div class="bar" id="bar"></div></div>
      </div>

      <div id="stage">
        <video id="video" autoplay playsinline muted></video>
        <canvas id="canvas"></canvas>
        <div class="hud">
          <div><b id="phase">대기</b> — <span id="hint" class="hint">"카메라 시작"을 누르고 권한을 허용하세요.</span></div>
          <div class="chips" style="margin-top:6px">
            <span class="chip">FPS <span id="fps">0</span></span>
            <span class="chip">키(cm) <span id="Hcm">—</span></span>
            <span class="chip">cm/px <span id="cmppx">—</span></span>
          </div>
          <div id="log" class="hint" style="margin-top:6px">—</div>
        </div>
      </div>

      <div class="row" style="margin-top:10px">
        <button id="btnPrev" disabled>이전</button>
        <button id="btnNext" disabled>다음</button>
        <div class="hint">① 정자세(전신) → ② 스쿼트 2~3회 → ③ 힙힌지 2~3회 → ④ 오버헤드</div>
      </div>
    </div>

    <!-- RIGHT -->
    <div class="card">
      <div class="sec">기본설정</div>
      <div class="row">
        <label>키(cm) <input id="height" type="number" min="120" max="220" step="1" value="175"></label>
        <label>몸무게(kg) <input id="weight" type="number" min="35" max="200" step="0.5" value="70"></label>
        <label>나이 <input id="age" type="number" min="13" max="90" value="22"></label>
      </div>
      <div class="row" style="margin-top:8px">
        <label>주의부위
          <select id="pain">
            <option value="none" selected>없음</option>
            <option value="knee">무릎</option>
            <option value="back">허리</option>
            <option value="shoulder">어깨</option>
            <option value="ankle">발목</option>
          </select>
        </label>
        <label>목표
          <select id="goal">
            <option value="fatloss" selected>체지방 감량</option>
            <option value="strength">근력 향상</option>
            <option value="mobility">가동성/교정</option>
            <option value="rehab">재활/통증완화</option>
          </select>
        </label>
      </div>

      <div class="sec">측정결과</div>
      <div class="kv"><span>스쿼트 최소 무릎각(°)</span><b id="minKnee">—</b></div>
      <div class="kv"><span>최대 상체 전굴(°)</span><b id="maxTrunk">—</b></div>
      <div class="kv"><span>무릎 내반 지표(+)↓</span><b id="valgus">—</b></div>
      <div class="kv"><span>오버헤드 리치</span><b id="overhead">—</b></div>

      <div class="sec">신체 길이/비율(추정)</div>
      <div class="kv"><span>허벅지 L/R (cm)</span><b><span id="lenThighL">—</span> / <span id="lenThighR">—</span></b></div>
      <div class="kv"><span>종아리 L/R (cm)</span><b><span id="lenShankL">—</span> / <span id="lenShankR">—</span></b></div>
      <div class="kv"><span>상완 L/R (cm)</span><b><span id="lenUA_L">—</span> / <span id="lenUA_R">—</span></b></div>
      <div class="kv"><span>전완 L/R (cm)</span><b><span id="lenFA_L">—</span> / <span id="lenFA_R">—</span></b></div>

      <div class="sec">개인 임계치(권장)</div>
      <div class="kv"><span>깊이(무릎각 ≤)</span><b id="thrDepth">—</b></div>
      <div class="kv"><span>전굴 허용(≤)</span><b id="thrTrunk">—</b></div>
      <div class="kv"><span>내반 허용(+ ≤)</span><b id="thrValgus">—</b></div>

      <div class="sec">Export</div>
      <textarea id="json" readonly></textarea>
      <div class="row" style="margin-top:8px">
        <button id="btnSave">브라우저 저장</button>
        <button id="btnCopy">JSON 복사</button>
        <button id="btnDownload">JSON 다운로드</button>
      </div>
      <div class="hint" style="margin-top:8px">브라우저 localStorage에 저장합니다. 이후 FastAPI 연동 예정.</div>
    </div>
  </div>
</div>

<script>
(async () => {
  // ===== Shortcuts / UI =====
  const $ = (id)=>document.getElementById(id);
  const video=$('video'), canvas=$('canvas'), ctx=canvas.getContext('2d');
  const btnStart=$('btnStart'), btnStop=$('btnStop'), btnPrev=$('btnPrev'), btnNext=$('btnNext');
  const ddCam=$('camera'), ddRes=$('reso'), chkMask=$('chkMask');
  const stepPill=$('stepPill'), bar=$('bar'), phaseEl=$('phase'), hintEl=$('hint');
  const fpsEl=$('fps'), logEl=$('log'), HcmEl=$('Hcm'), cmppxEl=$('cmppx');

  const minKneeEl=$('minKnee'), maxTrunkEl=$('maxTrunk'), valgusEl=$('valgus'), overheadEl=$('overhead');
  const thrDepthEl=$('thrDepth'), thrTrunkEl=$('thrTrunk'), thrValgusEl=$('thrValgus');
  const jsonEl=$('json');
  const lenThighL=$('lenThighL'), lenThighR=$('lenThighR'), lenShankL=$('lenShankL'), lenShankR=$('lenShankR');
  const lenUA_L=$('lenUA_L'), lenUA_R=$('lenUA_R'), lenFA_L=$('lenFA_L'), lenFA_R=$('lenFA_R');

  function log(m){ logEl.textContent=m; console.log('[calib]', m); }
  function setPhase(t,h=''){ phaseEl.textContent=t; hintEl.textContent=h; }

  // ===== Sanity: 라이브러리 확인 =====
  if (!window.tf || !window.poseDetection) {
    log('필수 라이브러리를 찾지 못했습니다. /static/lib/tf.min.js 와 /static/lib/pose-detection.min.js 가 있는지 확인하세요.');
    throw new Error('libs missing');
  }

  // ===== Detector =====
  let detector=null;
  async function loadDetector(){
    await tf.setBackend('webgl');
    await tf.ready();

    try {
      detector = await poseDetection.createDetector(
        poseDetection.SupportedModels.BlazePose,
        { runtime:'tfjs', modelType:'full' }
      );
      console.log('[detector] BlazePose (TFJS) ready');
    } catch(e){
      console.warn('[detector] BlazePose TFJS failed → MoveNet fallback:', e);
      detector = await poseDetection.createDetector(
        poseDetection.SupportedModels.MoveNet,
        { modelType: poseDetection.movenet.modelType.SINGLEPOSE_LIGHTNING }
      );
      console.log('[detector] MoveNet ready');
    }
  }

  // ===== Camera =====
  let stream=null;
  async function listCams(){
    const devs = await navigator.mediaDevices.enumerateDevices();
    const cams = devs.filter(d=>d.kind==='videoinput');
    $('camera').innerHTML = cams.map((c,i)=>`<option value="${c.deviceId}">${c.label||'카메라 '+(i+1)}</option>`).join('');
    if (!cams.length) log('카메라 장치를 찾지 못했습니다.');
  }
  async function startCam(){
    const [w,h] = $('reso').value.split('x').map(n=>+n||undefined);
    if(!stream){
      try{ log('카메라 권한 요청 중…'); await navigator.mediaDevices.getUserMedia({video:true,audio:false}); }
      catch(e){ log('권한 거부됨: 주소창 카메라 아이콘에서 허용으로 변경'); throw e; }
      await listCams();
    }
    if(stream){ stream.getTracks().forEach(t=>t.stop()); stream=null; }
    stream = await navigator.mediaDevices.getUserMedia({
      video:{ deviceId: $('camera').value? {exact:$('camera').value}:undefined, width:w, height:h },
      audio:false
    });
    video.srcObject = stream; await video.play();
    canvas.width = video.videoWidth; canvas.height = video.videoHeight;
  }

  // ===== Geometry / Utils =====
  function toDict(kps){ const d={}; (kps||[]).forEach(k=>{ const n=k.name||k.part; d[n]={x:k.x,y:k.y,z:k.z??0,score:k.score};}); return d; }
  function angle(d,a,b,c){ const A=d[a],B=d[b],C=d[c]; if(!(A&&B&&C)) return null;
    const ab={x:A.x-B.x,y:A.y-B.y}, cb={x:C.x-B.x,y:C.y-B.y};
    const dot=ab.x*cb.x+ab.y*cb.y, mag=Math.hypot(ab.x,ab.y)*Math.hypot(cb.x,cb.y)+1e-9;
    return Math.acos(Math.min(Math.max(dot/mag,-1),1))*180/Math.PI; }
  function segLen(d,a,b){ const A=d[a],B=d[b]; if(!(A&&B)) return null; return Math.hypot(A.x-B.x,A.y-B.y); }
  let cmPerPx=null;
  function pixelToCmFactor(dict,Hcm){
    const tops=['nose','left_eye','right_eye','left_ear','right_ear'].map(k=>dict[k]?.y).filter(v=>v!=null);
    const bots=['left_foot_index','right_foot_index','left_heel','right_heel'].map(k=>dict[k]?.y).filter(v=>v!=null);
    if(!tops.length||!bots.length) return null;
    const pxH = Math.max(...bots)-Math.min(...tops);
    if(pxH<120) return null;
    return Hcm/pxH;
  }

  // ===== Accumulators =====
  const accum={ minKneeL:+Infinity, minKneeR:+Infinity, maxTrunk:0, maxValgus:0, overheadOK:false,
    L:{thighL:null,thighR:null,shankL:null,shankR:null,uarmL:null,uarmR:null,farmL:null,farmR:null}};
  const ema=(p,c,a=.2)=>p==null?c:p*(1-a)+c*a;

  function updateROM(d){
    const kL=angle(d,'left_hip','left_knee','left_ankle');
    const kR=angle(d,'right_hip','right_knee','right_ankle');
    if(kL!=null) accum.minKneeL=Math.min(accum.minKneeL,kL);
    if(kR!=null) accum.minKneeR=Math.min(accum.minKneeR,kR);
    const tL=angle(d,'left_shoulder','left_hip','left_ankle');
    const tR=angle(d,'right_shoulder','right_hip','right_ankle');
    accum.maxTrunk=Math.max(accum.maxTrunk, Math.max(tL||0,tR||0));
    const hipL=d['left_hip'],kneeL=d['left_knee'],ankL=d['left_ankle'];
    const hipR=d['right_hip'],kneeR=d['right_knee'],ankR=d['right_ankle'];
    if(hipL&&kneeL&&ankL&&hipR&&kneeR&&ankR){
      const valgusL=(kneeL.x-hipL.x)-(ankL.x-hipL.x);
      const valgusR=(kneeR.x-hipR.x)-(ankR.x-hipR.x);
      accum.maxValgus=Math.max(accum.maxValgus,valgusL,valgusR);
    }
    const wL=d['left_wrist'], sL=d['left_shoulder'];
    const wR=d['right_wrist'], sR=d['right_shoulder'];
    if((wL&&sL&&wL.y<sL.y)||(wR&&sR&&wR.y<sR.y)) accum.overheadOK=true;
  }
  function updateLengthsPx(d){
    const L=accum.L;
    const thighL=segLen(d,'left_hip','left_knee');  if(thighL) L.thighL=ema(L.thighL,thighL);
    const thighR=segLen(d,'right_hip','right_knee'); if(thighR) L.thighR=ema(L.thighR,thighR);
    const shankL=segLen(d,'left_knee','left_ankle'); if(shankL) L.shankL=ema(L.shankL,shankL);
    const shankR=segLen(d,'right_knee','right_ankle');if(shankR) L.shankR=ema(L.shankR,shankR);
    const uarmL=segLen(d,'left_shoulder','left_elbow'); if(uarmL) L.uarmL=ema(L.uarmL,uarmL);
    const uarmR=segLen(d,'right_shoulder','right_elbow');if(uarmR) L.uarmR=ema(L.uarmR,uarmR);
    const farmL=segLen(d,'left_elbow','left_wrist');    if(farmL) L.farmL=ema(L.farmL,farmL);
    const farmR=segLen(d,'right_elbow','right_wrist');  if(farmR) L.farmR=ema(L.farmR,farmR);
  }
  function updateUI(){
    const minKnee=Math.min(accum.minKneeL,accum.minKneeR);
    minKneeEl.textContent=isFinite(minKnee)?Math.round(minKnee):'—';
    maxTrunkEl.textContent=accum.maxTrunk?Math.round(accum.maxTrunk):'—';
    valgusEl.textContent=accum.maxValgus?accum.maxValgus.toFixed(3):'—';
    overheadEl.textContent=accum.overheadOK?'예':'아니오';
    const kneeThr=isFinite(minKnee)?Math.round(Math.min(Math.max(minKnee+8,75),110)):null;
    const trunkThr=accum.maxTrunk?Math.min(Math.round(accum.maxTrunk+5),45):null;
    const valgThr=accum.maxValgus?Math.max(0.12,Math.min(0.25,accum.maxValgus+0.02)):0.12;
    thrDepthEl.textContent=kneeThr?`${kneeThr}°`:'—';
    thrTrunkEl.textContent=trunkThr?`${trunkThr}°`:'—';
    thrValgusEl.textContent=valgThr.toFixed(2);
    const f=cmPerPx||0, L=accum.L, show=(el,v)=>el.textContent=(v&&f)?(v*f).toFixed(1):'—';
    show(lenThighL,L.thighL); show(lenThighR,L.thighR); show(lenShankL,L.shankL); show(lenShankR,L.shankR);
    show(lenUA_L,L.uarmL); show(lenUA_R,L.uarmR); show(lenFA_L,L.farmL); show(lenFA_R,L.farmR);
    const profile={version:'v2',
      body:{height_cm:+$('height').value||null,weight_kg:+$('weight').value||null,age:+$('age').value||null,pain:$('pain').value,goal:$('goal').value},
      measures:{knee_min_angle_deg:isFinite(minKnee)?Math.round(minKnee):null,
        trunk_max_flexion_deg:accum.maxTrunk?Math.round(accum.maxTrunk):null,
        valgus_index_max:+(accum.maxValgus||0).toFixed(3),
        overhead_ok:!!accum.overheadOK,
        lengths_cm: cmPerPx?{
          thighL: L.thighL?+(L.thighL*cmPerPx).toFixed(1):null,
          thighR: L.thighR?+(L.thighR*cmPerPx).toFixed(1):null,
          shankL: L.shankL?+(L.shankL*cmPerPx).toFixed(1):null,
          shankR: L.shankR?+(L.shankR*cmPerPx).toFixed(1):null,
          upperArmL: L.uarmL?+(L.uarmL*cmPerPx).toFixed(1):null,
          upperArmR: L.uarmR?+(L.uarmR*cmPerPx).toFixed(1):null,
          forearmL: L.farmL?+(L.farmL*cmPerPx).toFixed(1):null,
          forearmR: L.farmR?+(L.farmR*cmPerPx).toFixed(1):null
        }:null},
      thresholds:{knee_depth_angle_le:kneeThr,trunk_flexion_max_deg:trunkThr,valgus_index_max:+valgThr.toFixed(2),shoulder_flexion_goal_deg:160},
      notes:'BlazePose 기반 개인바프 프로파일'};
    $('json').value=JSON.stringify(profile,null,2);
  }

  // ===== Draw =====
  function drawSkeleton(kps, mask){
    const W=canvas.width,H=canvas.height; ctx.clearRect(0,0,W,H);
    if(chkMask.checked && mask){ ctx.save(); ctx.globalAlpha=.35; ctx.drawImage(mask,0,0,W,H); ctx.restore(); }
    const d={}; (kps||[]).forEach(k=>{ if(k.score>0.3) d[k.name||k.part]=k; });
    ctx.lineWidth=3; ctx.strokeStyle='#39b3ff'; ctx.fillStyle='#ffde6b';
    const pairs=[['left_shoulder','left_elbow'],['left_elbow','left_wrist'],['right_shoulder','right_elbow'],['right_elbow','right_wrist'],['left_shoulder','left_hip'],['right_shoulder','right_hip'],['left_hip','left_knee'],['left_knee','left_ankle'],['right_hip','right_knee'],['right_knee','right_ankle']];
    pairs.forEach(([a,b])=>{ const A=d[a],B=d[b]; if(A&&B){ ctx.beginPath(); ctx.moveTo(A.x,A.y); ctx.lineTo(B.x,B.y); ctx.stroke(); }});
    (kps||[]).forEach(k=>{ if(k.score>0.45){ ctx.beginPath(); ctx.arc(k.x,k.y,4,0,Math.PI*2); ctx.fill(); }});
  }

  // ===== Steps & Loop =====
  let step=0,running=false,raf=0,last=performance.now();
  function setStep(s){
    step=s;
    stepPill.textContent=`STEP ${Math.min(step,4)}/4: `+(['준비','정자세(키 보정)','스쿼트','힙힌지','오버헤드','요약'][step]||'요약');
    bar.style.width=`${Math.min(step,4)/4*100}%`;
    btnPrev.disabled=(step<=1); btnNext.disabled=(step<=0);
    if(step===1) setPhase('정자세','전신이 모두 보이게 서 있으세요(키 보정)');
    if(step===2) setPhase('스쿼트','자연스럽게 2~3회 내려갔다 올라오세요');
    if(step===3) setPhase('힙힌지','엉덩이를 뒤로 빼며 상체 전굴 2~3회');
    if(step===4) setPhase('오버헤드','양팔을 귀 옆으로 곧게 들어 올려보세요');
    if(step===5) setPhase('요약','결과를 확인하고 저장하세요');
  }

  async function loop(){
    if(!running) return;
    let poses=null;
    try{ poses=await detector.estimatePoses(video,{flipHorizontal:true}); }
    catch(e){ log('추론 오류: '+(e?.message||e)); requestAnimationFrame(loop); return; }
    canvas.width=video.videoWidth; canvas.height=video.videoHeight;
    if(poses && poses[0]){
      const p=poses[0]; drawSkeleton(p.keypoints, p.segmentationMask);
      const dict=toDict(p.keypoints);
      const H=+$('height').value||null; HcmEl.textContent=H||'—';
      if(H && !cmPerPx && step>=1){
        const f=pixelToCmFactor(dict,H);
        if(f){ cmPerPx=f; cmppxEl.textContent=f.toFixed(3); log('키 보정 완료 (cm/px 산출)'); }
        else{ cmppxEl.textContent='—'; }
      }
      updateROM(dict); updateLengthsPx(dict); updateUI();
    }
    const now=performance.now(); const fps=1000/Math.max(1,now-last); last=now; fpsEl.textContent=String(Math.round(fps));
    raf=requestAnimationFrame(loop);
  }

  // ===== Handlers =====
  btnStart.onclick=async()=>{
    btnStart.disabled=true; btnStop.disabled=true;
    try{
      await startCam(); log('카메라 시작 ✔');
      if(!detector){ setPhase('모델 로딩','잠시만…'); await loadDetector(); }
      setPhase('준비 완료','정자세 단계로 이동하세요'); running=true; setStep(1);
      btnNext.disabled=false; btnStop.disabled=false; loop();
    }catch(e){
      log('시작 실패: '+(e?.name||'')+' '+(e?.message||e)); btnStart.disabled=false;
    }
  };
  btnStop.onclick=()=>{
    running=false; cancelAnimationFrame(raf);
    if(stream){ stream.getTracks().forEach(t=>t.stop()); stream=null; }
    setPhase('중지','다시 시작하려면 "카메라 시작"을 누르세요');
    btnStart.disabled=false; btnStop.disabled=true; cmPerPx=null; cmppxEl.textContent='—';
  };
  btnPrev.onclick=()=>{ if(step>1) setStep(step-1); };
  btnNext.onclick=()=>{ if(step<4) setStep(step+1); else setStep(5); };

  $('camera').onchange=async()=>{ if(stream){ try{ await startCam(); }catch{} } };
  $('reso').onchange=async()=>{ if(stream){ try{ await startCam(); }catch{} } };

  // Export
  $('btnSave').onclick=()=>{ try{ const d=JSON.parse(jsonEl.value||'{}'); localStorage.setItem('calibration.v2', JSON.stringify(d)); alert('저장되었습니다 (localStorage: calibration.v2)'); }catch{ alert('JSON 저장 실패'); } };
  $('btnCopy').onclick=()=>{ navigator.clipboard.writeText(jsonEl.value||'{}').then(()=>alert('복사 완료')); };
  $('btnDownload').onclick=()=>{ const blob=new Blob([jsonEl.value||'{}'],{type:'application/json'}); const a=document.createElement('a'); a.href=URL.createObjectURL(blob); a.download='calibration_profile.json'; a.click(); URL.revokeObjectURL(a.href); };

  // Init
  if(!('mediaDevices' in navigator)) log('브라우저가 카메라를 지원하지 않습니다.');
  await listCams();
  setStep(0);
})();
</script>
</body>
</html>
